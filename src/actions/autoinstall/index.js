let { existsSync, renameSync, writeFileSync } = require('fs')
let { join } = require('path')
let getRootDeps = require('./get-root-deps')
let getSharedDeps = require('./get-shared-deps')
let getLambdaDeps = require('./get-lambda-deps')

module.exports = function autoinstaller (params) {
  let { cwd, dirs, inventory, update, verbose } = params
  if (!dirs.length) return []

  update.start('Finding dependencies')

  // Generated manifests to be hydrated later (if there are no parsing failures)
  let installing = []

  // Userland files that could not be parsed
  let failures = []

  // Get package[-lock] dependencies
  let allDeps = getRootDeps(inventory)

  // Stats
  let start = Date.now()
  let projectDirs = 0
  let projectFiles = 0
  let totalDeps = 0

  // Aggregate shared + views deps
  let shared = getSharedDeps({ cwd, inventory, update })
  let { sharedDeps, sharedFiles, viewsDeps, viewsFiles } = shared
  projectDirs += shared.projectDirs
  projectFiles += shared.projectFiles

  dirs.forEach(dir => {
    projectDirs++
    let lambda = inventory.inv.lambdasBySrcDir[dir]
    if (Array.isArray(lambda)) lambda = lambda[0] // Handle multitenant Lambdae

    // Autoinstall is currently Node.js only - exit early if it's another runtime
    if (!lambda.config.runtime.startsWith('nodejs')) return
    try {
      let result = getLambdaDeps({ dir, update, inventory })
      let { deps, files } = result
      projectFiles += files.length
      failures = failures.concat(result.failures)

      if (lambda.config.shared) {
        deps = deps.concat(sharedDeps)
        files = files.concat(sharedFiles)
      }
      if (lambda.config.views) {
        deps = deps.concat(viewsDeps)
        files = files.concat(viewsFiles)
      }
      deps = [ ...new Set(deps.sort()) ] // Dedupe

      // Exit now if there are no deps to write
      if (!deps.length) return
      totalDeps += deps.length

      // Build the manifest
      let dependencies = {}
      deps.forEach(dep => dependencies[dep] = allDeps[dep] || 'latest')
      let lambdaPackage = {
        _arc: 'autoinstall',
        _module: 'hydrate',
        _date: new Date().toISOString(),
        _parsed: files.sort(),
        description: `This file was generated by Architect, and placed in node_modules to aid in debugging; if you found file in your function directory, you can safely remove it (and package-lock.json)`,
        dependencies,
      }
      let params = {
        dir,
        file: 'package.json',
        remove: [ 'package.json', 'package-lock.json' ], // Identify files for later removal
        data: JSON.stringify(lambdaPackage, null, 2)
      }
      // Autoinstall can be called on a directory that contains a package.json with `"type": "module"` (and no dependencies)
      // If we find such a case, kindly move the existing package.json aside until autoinstall ops are complete
      if (existsSync(join(dir, 'package.json'))) {
        params.swap = 'package.json.bak'
      }
      installing.push(params)
    }
    catch (err) {
      update.error(`Error autoinstalling dependencies in ${dir}`)
      throw err
    }
  })

  // Halt hydration (and deployment) if there are dependency determination issues
  if (failures.length) {
    update.error('JS parsing error(s), could not automatically determine dependencies')
    failures.forEach(({ file, error }) => {
      console.log('File:', file)
      console.log(error)
    })
    process.exit(1)
  }

  // Write everything at the end in case there were any parsing errors
  installing.forEach(({ dir, file, swap, data }) => {
    let manifest = join(dir, file)
    if (swap) {
      renameSync(manifest, join(dir, swap))
    }
    writeFileSync(manifest, data)
  })

  if (verbose) {
    let stats = [
      `Scanned ${projectDirs} project dirs`,
      `Inspected ${projectFiles} project files`,
      `Found a total of ${totalDeps} dependencies to install`
    ]
    update.status('Dependency analysis', ...stats)
    update.done(`Completed in ${Date.now() - start}ms`)
  }
  else update.cancel()

  return installing
}
